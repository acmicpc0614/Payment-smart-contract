\documentclass[a4paper,12pt]{article}
\usepackage{caption}
\usepackage{float}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{amsfonts}
\usepackage{amsmath}

\usepackage[utf8]{inputenc}
\usepackage{biblatex}

\input{./solidity-highlighting.tex}
\input{./vyper-highlighting.tex}

\addbibresource{bibliography.bib}

\title{Accountant pattern: Lightweight solution for embedded micropayments}
\author{Jaro Šatkevič, me@JaroCoin.com}

\begin{document}

\maketitle

The growing number of decentralised platforms which require embedded payment 
mechanisms means that the need for a high throughput micro-payments solution 
using cryptocurrencies is larger than ever before. 

Presently, blockchain payments must be verified and stored by each node in the 
network. This means that sets the limit for the overall throughput of the system.

There are several off-chain protocols - \textit{Lightning Network}, \textit{Raiden}
or various \textit{Plasma} implementations. While they each provide solutions for 
specific use cases of micropayments with cryptocurrencies, they come with varying 
sets of limitations when it comes to high throughput micropayments in decentralized 
systems. 

In this paper, we provide a construct of an embeddable, lightweight micropayment 
solution - \textit{"Accountant pattern"}.

Mysterium Accountant combines techniques used by payment hubs and digital cheque 
based unidirectional channels. This means the ability to provide up to couple of
millions transactions per second. This best serves the needs of decentralized VPN, 
CDN or video streaming platforms. 


\newpage
\tableofcontents
\newpage

\section{Introduction}

The idea of building decentralized systems is not new. The main addition that 
cryptocurrencies have brought to decentralized protocols is the ability to enable 
incentivisation. This is done via embedded payment mechanisms. 

In decentralized systems, it is often the case that two parties that do not trust 
each other want to carry out mutual transactions. This is especially relevant in 
the case of a decentralized VPN network. \\

\textbf{Trustless transactions - the heart of a decentralized VPN network} \\

Considering the nature of a decentralized VPN network, one can assume that network
participants would prefer to remain anonymous. Given the lack of trust, a service 
consumer will not be willing to pay a bigger amount up front. On the other end, the 
service provider isn’t willing to deliver service without prepayment. 

From this above mentioned scenario arises a need to split the service into chunks
- provided in exchange for micropayments - meaning that each party risks a much 
smaller value. Put into context within a decentralized VPN network, this would 
mean that a user will pay a node a couple of times a minute, sending a tiny amount 
of tokens in exchange for the bandwidth they are renting. 

With cryptocurrencies, it is now possible to embed decentralized payment solutions 
in a trustless and permissionless way. Unfortunately, because of technical 
limitations, to make scalable cryptocurrency payments, additional work is required. 

The backbone of cryptocurrencies is a technology called the \textit{blockchain}. 
This technology requires each transaction to be stored on the ledger and replicated 
across thousands of network participants. This imposes a fundamental limit on the 
number of transactions that can be processed. 

Let’s take two of the most popular blockchains, Bitcoin and Ethereum. Their 
blockchains can provide throughput of 3 to 25 transactions per second causing high
transaction fees and making on-chain transactions too expensive for micropayments. 

To overcome blockchain scalability problems, several approaches have been 
proposed:

\begin{itemize}
    \item \textit{\textbf{Speedup blockchain}} itself by changing some 
    fundamental components.
    \item Use \textit{\textbf{blockchain attuned to use-cases}} (sidechains, 
    Cosmos and Polkadot networks). 
    \item \textit{\textbf{Plasma}} and other kinds of child-chain solutions.
    \item Payment and \textit{\textbf{state channels}} based solutions.
\end{itemize}

Most of the proposed solutions are in extremely early stages of development and 
adoption. Each come with their own pros and cons and there is currently no clear 
industry standard.

This lack of payment standardization is one of the contributing reasons to 
decentralized protocols still being early betas. While some may already have
working core solutions, payments are often a missing and evolving piece. \\

\textbf{The goal of this whitepaper is to lay out research on the simplest, 
cheapest and powerful solution for high throughput micropayments using 
tokens}. This is in the context of creating a payments infrastructure for 
decentralized VPN, CDN or streaming services. \\

Here is the methodology we have undertaken to understand the problem and lay out
the solution for high throughput micropayments: 

\begin{enumerate}
    \item Analyse the needs of decentralized VPN, CDN or streaming platforms, 
    collecting requirements for payment solutions which are applicable.
    \item Research and compare advantages, limitations and side effects of current
    layer two solutions. We will look at state channels, micropayment channel 
    networks, plasma and sidechains. In this research, we will dive into the 
    possibility of the use of each of these layer two solutions as a base for high
    throughput micropayments in decentralized platforms.
    \item Detail a lightweight and easily embeddable solution for high throughput
    micropayments. 
\end{enumerate}

\section{Platfrom review and requirements for payment solution}

Let us take the case of Mysterium Network \cite{mysterium} - the world’s first 
decentralized VPN. This is a decentralized application which requires high throughput 
micropayments. 

Mysterium Network is a network of nodes providing security and privacy for end 
users of MysteriumVPN, a decentralized VPN application.

The goal of Mysterium Network is to combine powerful encryption mechanisms, 
reputation management systems and layered protection protocols to build an 
infinitely scalable P2P architecture. A decentralized VPN is fundanmentally 
different from current in-market VPN solutions in that it’s architecture is 
fundamentally decentalized. The long term vision of Mysterium Network is to build 
a system where there is no single point of faliure in the network. This is possible
as the network, in the case of Mysterium Network, is a community of incentivised 
nodes renting their bandwidth in exchange for payment.

This means that no government, company or person will be able to censor or stop 
the service. Even the team of Mysterium Network will be not able to censor or stop 
the network once the final solution has been released into production.

\subsection{Components of the Network}

\begin{itemize}
    \item \textbf{Provider nodes:} This is a service written in golang which can 
    be run by any user of the network. This service allows you to earn crypto 
    currency for renting your bandwidth to other users (consumers) using OpenVPN.
    \item \textbf{Consumer app:} This is a dApp written in golang and JavaScript 
    which can be run by any user of the network to connect to provider nodes via 
    OpenVPN and rent their bandwidth.
    \item \textbf{Discovery service:} Discovery service helps providers to advertise
    themselves in the network. This allows consumers to find them and rent their 
    bandwidth.
    \item \textbf{Myst token:} This is the utility token used within Mysterium 
    Network. MYST is the main and only method of P2P payment within the network. 
    MYST token is released as an ERC20 token on Ethereum blockchain.
    \item \textbf{Mysterium ID:} Each user of the network (consumers and providers)
    has to register a Mysterium Identity, which is similar to an Ethereum address 
    (20 bytes of keccak256 hash of the public key derived from private key using 
    elliptic curve cryptography).

    Mysterium ID is needed to:
    \begin{itemize}
        \item Uniquely identify network actors;
        \item Be able to securely establish connections between them;
    \end{itemize}

    Mysterium ID has to be registered on-chain using smart contracts deployed into 
    Ethereum network.
\end{itemize}

\subsection{Initially proposed payment solution}

Initially, the Mysterium team was planning to use a mechanism which remotely 
resembled the way cheques work. A blockchain account holder can write a 
cryptographic cheque to another account (the beneficiary) as a form of payment. 
A cheque would include the issuer’s address, beneficiary’s address, the sum of 
the total promised, the sequence and signatures. The amount is written on the 
cheque can be updated and only the last version of the cheque is valid. The 
beneficiary can settle the promised account on blockchain at a later date.

Here is a snippet from the smart contract code which settles the promised value 
on-chain.

\begin{lstlisting}[language=Solidity]
    function settlePromise(address issuer, 
                           address beneficiary, 
                           uint256 seq, 
                           uint256 amount, 
                           bytes issuerSignature,
                           bytes beneficiarySignature) public {
        bytes32 promiseHash = keccak256(beneficiary, seq , amount);

        address recoveredIssuer = ecrecover(promiseHash, issuerSignature);
        require(recoveredIssuer == issuer);

        address recoveredBeneficiary = ecrecover(promiseHash, beneficiarySignature);
        require(recoveredBeneficiary == beneficiary);

        require(seq > clearedPromises[issuer][beneficiary]);
        clearedPromises[sender][receiver] = seq;

        require(token.balanceOf(issuer) >= amount);
        token.transferFrom(issuer, beneficiary, amount);

        emit PromiseSettled(issuer, beneficiary, seq, amount);
    }
\end{lstlisting}

This solution is much better than doing on-chain transactions for each layer of 
this transaction. 

Cheques with promised amounts can be sent from consumer to provider peer to peer 
each second. Only the \textit{consumer} and \textit{provider} will be aware of 
these changes in states, until the \textit{provider} finally decides to settle 
transactions on the blockchain. This will drastically reduce the amount of 
on-chain transactions while providing a secure way for two parties that don’t 
trust each other to transact. 

\subsubsection{The fundamental issues with digital cheques}

In this section we will define what a digital cheque is, and explore fundamental
flaws that have yet to be fixed. 

A digital cheque is a cryptographic signature which can be sent into smart contact 
to prove ownership of tokens and empowers smart contract to send tokens into given 
in that signature address.

Here are some of the issues we face with digital cheques: 

\begin{enumerate}
    \item \textbf{Double spending}\\
    When there isn’t enough funds in the issue’s balance to cover the promised 
    value, the transaction will be rejected when it is settled into the blockchain. 
    This creates the possibility of double spending. A consumer may be able to 
    issue a cheque for the same funds to another party. 

    In the case of a VPN service, this isn’t a huge problem as bandwidth is a 
    \textit{“perishable product”}. However, this risk of double spending forces 
    more regular on-chain settlements. Service providers would be settling each 
    time the promised amount was big enough that the risk of losing that value 
    outweighed the cost of the transaction. 

    \item \textbf{Small value cheques}\\
    Within the decentralized VPN system, a consumer could use a provider’s service 
    only once and for a limited time (e.g. one hour unblocking Netflix). This means 
    that providers will accumulate a lot of small value digital cheques (e.g. 0.10 
    USD value in tokens). Settling one cheque on the Ethereum blockchain can cost 
    from 0.01 up to 1 USD depending on network congestion. This means that either 
    large fees will be paid or these cheques will remain unsettled.
\end{enumerate}

\subsection{Requirements for an “ideal” payments solution}

Due to the high level of privacy and anonymity in decentralized networks, actors 
within the network do not trust each other. Additionally, there is no trusted 
intermediary available which can act as a custodian or help with conflict 
resolution. In these situations, the consumer isn’t going to pay a large amount 
up-front and the service provider will be unlikely to offer services without 
prepayment.

In the case of a decentralized VPN, a service can be split into microservices and 
provided in exchange for micropayments, reducing the risk for both parties.

This \textit{pay-as-you-go} model means that both parties begin transacting 
immediately, with transactions occurring a couple of times a minute while 
sending small amounts of cryptocurrency.

\begin{enumerate}
    \item \textbf{Consumer to Provider payments}\\
    Usually there are two actors in the network, consumers and providers of a 
    service. All payments are sent by consumers and received by providers. Never 
    vice versa.

    Thanks to this observation, the protocol can be simplified and make use of 
    \textit{payment promises} or \textit{uni-directional} micropayments channels.

    \item \textbf{High throughput and scalability}\\
    It is extremely important that the protocol is able to support frequent small 
    payments (e.g. 10 seconds by all participating parties of values less than 1 
    cent). This means that:
    \begin{itemize}
        \item The payment solution should be able to process as many transactions 
        per second as there are active sessions established between service 
        providers and consumers.
        \item Value of a transaction should be set to parts of a cent (in given 
        cryptocurrency).
        \item Transactions should be marked as final in a very short period of 
        time. They ideally should have an \textit{instant finality} property.
        \item Fast answers about transaction status with minimal neworking errors 
        and retry amounts.
        \item Transaction fees have to be very small (parts of a penny) or 
        expressed as a percentage of the transaction value.
        \item There should be minimal presence on-chain. This system would need 
        to aggregate payments of many sessions and from different consumers, to 
        settle them in one transaction on chain.
    \end{itemize}

    \item \textbf{Utility token and stable coin support}\\
    Bitcoin, Ether or other popular cryptocurrencies are volatile and may not be 
    accepted as payment in certain cases. Further there are several decentralized 
    apps which have issued their own utility token (\textit{MYST} in the case of 
    Mysterium Network). This means there is a requirement for payment protocols 
    to support transactions using \textit{ERC20} tokens issued on Ethereum 
    blockchain.

    \item \textbf{Security}\\
    Digital services such as VPN can be seed as \textit{perishable} as they are 
    renting traffic which if not used, is “gone” forever. This means that some 
    level of risk of unpaid service can be acceptable. However, it should be up 
    to the service provider to weight this level of risk against convenience 
    (usability and performance) and cost (lower on-chain settling fees). In a 
    general case, this double spending attempt has to be immediately identified 
    and such transactions, rejected.

    Anonymity, and the permissionless nature of decentralized systems create 
    cases where additional layers of protection against bad actors is required. 
    For example, in the case of a decentralized VPN, poorly performing service 
    providers may simply refresh their identities by simply creating a new 
    identity in the network. Bad acting consumers could organise DDoS attacks, 
    and it would be impossible for providers to ban them as they too could 
    continuously create new identities.

    To curtail this behaviour we need a reputation system which incorporates 
    identity registration, staking and a punishment system.

    \begin{itemize}
        \item network identity have to be registered in given smart-contract, to
        do so there should be paid registration fee or staked given amount of 
        tokens;
        \item there should be not possible to pay with same coin twice (avoid 
        double spending);
        \item system should be secure against different kind of attacks (e.g. 
        DDos);
    \end{itemize}

    \item \textbf{Decentralization}\\
    Components as important as payments should have a high degree of liveness.

    There should be no central party which is easy to shut down and censor. This
    means that the payment protocol that is needed should maintain at least some 
    level of decentralization and should not be operated by any party.

    \item \textbf{Low complexity implementation}\\
    There are several potential ways we can embed payment solutions into 
    decentralized platforms. We could either progress with a popular and scalable 
    payment network which already works on several platforms, has stable APIs and 
    is already in use in many communities.

    Or we could work with a solution with a low level of complexity so it could be 
    easy to implement, cheap to operate and resource efficient to use. 

    \begin{enumerate}
        \item \textbf{Easy implementation.} Such protocol needs to be used and 
        modified to suit the needs of various systems. This means it is necessary 
        that each of it’s main parts can be reimplemented in main programming 
        languages in a matter of weeks.
        \item \textbf{Cheap to operate.} To make solutions easier to decentralize, 
        it should be relatively easy and cheap to run and operate nodes. No big 
        initial financial investment, complicated installation and advanced 
        hardware should be used.
        \item \textbf{Efficient usage.} Since there is a requirement to create a 
        stable and fast payment solution, the less communication messages that 
        need to be exchanged between parties, and the less intermediaries involved, 
        the better for the protocol.
    \end{enumerate}

    \item \textbf{Good user experience}\\
    Technical parameters alone do not make for successful systems. If there is 
    friction involved in a user making a payment, we will not be geared towards 
    adoption.

    Here are various usability considerations that we need to solve for:
    \begin{enumerate}
        \item Consumers should be able to deposit funds using any popular crypto 
        wallet, or directly from exchanges.
        \item Users should have the possibility to own just one asset (e.g. MYST 
        token) and not be required to own any additional utility token or coin to 
        make payments within the network. This is especially important when 
        considering the ERC20 nature of MYST, and the need to settle on the 
        Ethereum blockchain, which requires a fee in ETH for each transaction. 
        \item Any cryptographic proof should be able to be transferred not only 
        by a signing party, but by any third party. All while maintaining the same
        level of security. \textbf{This allows the use of cloud trustless services 
        to send, valid and protect transactions.}
        \item Since service providers are earning income within the system, they 
        can be required to stake tokens or pay a platform fee. Consumers however 
        need the freedom to use the network without staking.
    \end{enumerate}
\end{enumerate}

\section{Overview of potential solutions}

\textit{Blockchain} is a replicated state machine which orders transactions on 
it's global state. Transactions are verified and replayed by each participant,
called a \textit{node}, in the network. This limists the throughput of the 
network as a whole to the lowest throughput of any of it's nodes. Increasing 
the load beyond that throughput may result in nodes unable to handle the load 
being pushed out of the network. This impose a fundamental limit of amount of 
transactions which can be processed. 

Let's take two most popular cryptocurrencies Bitcoin and Ethereum. Their 
blockchains can provide throughput of 3 to 15 transactions per second which in 
busy period causes high transaction fees and makes on-chain transactions too 
expensive for micropayments.

One of solutions would be to increase block size which could allow increase 
throughput. There are blockchains with block limits of 128Mb (100 times higher 
that bitcoin's) so theoretically they can process up to couple of hundreds 
transactions per second. Such level of scalability work for one-time type of 
payments (like buying cup of coffee) but for high throughput nano payments we 
need solution which could process millions of transactions per second. 
Unfortunatelly there are phisical network, validation time (CPU) and disk space 
limits so blocks can't be ultimately big.

Finally there is one more problem. Participants in the network by default agree 
that the chain with the highest \textit{difficulty} or more blocks put into it, 
is “true ledger”. If some other branch mined in parallel will get longer chain, 
a new ledger is accepted as the true ledger. Some transactions accepted into 
older ledger can be not added into new one. This means that the longer waiting 
period before accepting payment, the bigger guarantee the transaction written 
in blockchain is irreversible.

For frequent transactions, the faster \textit{finality} there is, the better. 
\textit{On-chain} transactions however don't have reasonably fast finality.\\

To overcome \textit{on-chain} limitations, such as scalability, high fees and
long finality time, several \textit{off-chain} protocols (or so-called 
\textit{Layer 2} solutions) have been proposed. Among these techniques, one 
important differentiator is whether the relocated operations introduce 
additional consensus assumptions (like in sidechains and interoperable 
blockchain networks such as Polkadot or Cosmos), or allow users to restore their
state to the original blockchain (like in state channels or Plasma).

\subsection{Blockchain per project}

The most radical solution would be to move platform specific utility token into 
own blockchain. There are couple of frameworks to build own blockchains with 
plugable consensus and application layer. Most promissing solutions are 
\textit{Tendermint} developed by Cosmos Network, \textit{Substrate} developed
by Parity Technologies as part of Polkadot Network, using software of Ethereum
but with different consensus algorithm and \textit{Hyperledger Fabric} by Linux
Foundation.

Nevertheless that these solutions are relatively hard to customise and launch, 
using them would additionally require building community of full nodes and stake 
pools which would guaranty network's security. Another unwanted side effect 
would be need of moving token into new blockchain. This is socialy complicated 
and hard to implements project. \\

Alternatively there could be launched a \textit{sidechain} - a blockchain ledger 
that runs in parallel to a primary blockchain. Assets from the main blockchain 
can be linked to and from the sidechain. This allows the sidechain to operate 
independently of the primary blockchain by introducing own consensus mechanism, 
faster speed of transactions and features needed to some dedicated platform.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.5]{../img/sidechain}
    \caption{Two-way pegged sidechain}
    \label{img:sidechain}
\end{figure}

Thanks to possibility to use own, less decentralised but more scalable consensus
algorithms, \textit{sidechains} can provide much higher throughput than in 
primary blockchain. However while introducing consensus assumptions which in 
situation of fail will permanently compromise long-term guarantees (such as 
persistence of asset ownership). If state is "moved" to a sidechain and that 
chain's consensus mechanism fails, owners or beneficiaries of that state may 
lose everything delegated there, even when the primary blockchain remains
secure.

Slightly different approach is taken by interoperable multi-chain networks such 
as \textit{Polkadot} (see figure \ref{img:polkadot}) which allows new designs of
blockchains (called parachains) to communicate and pool their security while 
still allowing them to have the entirely arbitrary state-transition functions. 
This helps to bootstrap new chain much faster while having same security 
guaranties as whole Polkadot network.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.5]{../img/polkadot}
    \caption{Polkadot network components}
    \label{img:polkadot}
\end{figure}

Despitethe the fact that \textit{sidechains} can provided significant increase 
of transaction throughput and in case of \textit{multi-chains} also relatively
easy achievable high level of security guarantees, general issues of blockchains
still apply. Because of blockchain nature and physical networking and storage 
limitations, they still can't provide throughput of hundreds of thousands 
transactions per second and \textit{instant finality}, which may be needed for 
\textit{micropayments} in succesfull decentralised VPN or streeming platform.

\subsection{Plasma}

\textit{Plasma} \cite{plasma} is a proposed framework for scaling Ethereum 
capacity by using hierarchical sidechains. Plasma type of sidechains (also 
called child chains) allow to do a majority of transactions outside of the "root
chain" (e.g. Ethereum). Only deposits and withdrawals, the points of entry and 
exit, are handled on the root chain smart contract.

Similary to blockchains Plasma chain stores all it's transactions packed into 
blocks while using \textit{UTXO} for balance accounting. To make sure that 
transactions are final, Plasma operator is doing something called a "state 
commitment". It is a cryptographic way to store a compressed version of the 
state of child-chain inside of root chain. Typically all the state is stored in
\textit{merkle trees} and only \textit{merkle root} of each block's state is 
persisted into root chain.

Usually Plasma chains are run by single operators, having distributed nodes 
using some kind of Byzantine Fault Tolerant (BFT) consensus (e.g. Proof of 
Stake) is possible though.

Differently to sidechains and multi-chains, Plasma makes possible for users to 
leave at any time. Such action is usually refered as “exiting”. This allows users 
safely withdrawal their funds out of Plasma even if it was shutdown by operator.

While it offers significant speed (up to 1000 tx/s) and latency improvements 
over Ethereum itself, Plasma cannot offer the near-zero latency and near-free 
transaction fees. It also requires significat storage to store it's ledger
(esoecially with big amounts of transactions).\\

Another downside of Plasma chais is that it is complex and difficult to 
implement solution. Especially hard is to run it with distributed nodes which 
have BFT type of consensus. When Plasma chain is operated with single operator, 
there is risk that he will create 'fake' blocks, which may end up with mass 
exits out of plasma into root chain and stuck of whole network.\\

One more downside is that plasma is quite expensive to operate. Each couple of 
blocks it have to commit it's state to root chain, which means, that plasma 
operator would have to pay 1080 USD (as gas fee) per day. 

\[ 3 \thinspace tx / minute * 1 440 \thinspace minutes / day = 4320 \thinspace tx/day \]
\[ 1 \thinspace tx = 25 \thinspace cents \]
\[ 4320 \thinspace tx/day * 0.25 USD/tx = 1080 \thinspace USD/day \]

This isn't big problem when there is already significant load in the network, 
however in the beginning covering such costs can be problematic.\\

And finaly, regardless of that Plasma transaction throughput is significantly 
higher than Ethereum's, it is still not enought for distributed VPN network 
needs. As alternative, there could be possible to build some kind of payments 
channels on top of Plasma (see \ref{img:plasma-channels}). In this way parties 
could do peer-to-peer transactions while having active service and close 
channels right after closing connection. 

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.5]{../img/plasma-channels}
    \caption{Plasma + payment channels}
    \label{img:plasma-channels}
\end{figure}

In situation when there are more that one transaction per second throughput, 
Plasma transactions can be relativelly cheap (less that 1 cent per transaction)
and can have fast including into block (from 1 to 10 seconds, depending on 
implementation). This allow opening and closing channels when needed and avoding
long waiting times.

Unfortunatelly this solution is even more complicated that using just plasma and
has similar cost and decentralisation issues mentioned above.

\subsection{Payment and state channels based solutions}

A \textit{micropayment channel} is class of techniques designed to allow parties
to exchange digital value without commiting all of the transactions to the 
blockchain. In a typical payment channel, only two transactions are added to the 
blockchain but an unlimited or nearly unlimted number of payments can be made 
between participants.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.5]{../img/payment-channel}
    \caption{Sequense based payment channel}
    \label{img:payment-channel}
\end{figure}

To open payment channel parties have to lock some funds into multisignature 
smart contract (see figure \ref{img:payment-channel}). This allows parties to
updated channels balances off-chains while beeing sure with hight probability 
that funds will be not double spent or stolen.

There are various payment channels techniques such as sequence based channels, 
duplex channels, time-locked channels, etc. Any of them would improve security 
and would help to avoid double spending problems comparing to initially proposed
digital cheques solution (see section 2.2). Also that would allow providers to
wait longer until settling on-chain what could reduce settling costs because 
some consumers may return to use service via same provider again. \\

\subsubsection{State channels}

State channels are the general form of \textit{payment channels}, applying the
same idea to any kind of state-altering operation normally performed on a 
blockchain. Moving these interactions off of the chain without requiring any 
additional trust can lead to significant improvements in cost and speed. State 
channels will be a critical part of scaling blockchain technologies to support 
higher levels of use.

The basic components of a state channel are very similar to that in payment 
channels.

\begin{enumerate}
    \item Part of the blockchain state is locked via multisignature type of smart 
    contract, so that a specific set of participants must completely agree with 
    each other to update it.
    \item Participants update the state among themselves by constructing and 
    signing transactions that could be submitted to the blockchain, but instead 
    are merely held onto for now. Each new update "trumps" previous updates.
    \item Finally, participants submit the state back to the blockchain, which 
    closes the state channel and unlocks the state again (usually in a different 
    configuration than it started with).
\end{enumerate}

Because tokens on Ethereum blockchain are represented in form of state in smart 
contracts, state channels are the way how to move token interacion into 
\textit{layer 2}.\\

\subsubsection{Downsides and benefits of channels}

The downside of using payment channels is that parties have to lock funds into 
multisigature smart contracts which in comparison to \textit{digical cheques} 
means additional on-chain transaction for opening channel and needs of having 
locked bigger amounts of funds. There is not possible to reuse same funds in 
another channel before closing previous one. Another downside is time to 
service. Opening new channel will take some time (depending on type of 
blockchain and network load this make take from one minute till up to couple 
of hours) which makes bad user experience.\\

There are also couple of additional benefits of payment channels:

\begin{itemize}
    \item \textbf{Privacy} -- each transaction is known only to participating 
    parties, which allows them to have privacy in their individual transactions 
    such that the public only knows the result which has been shared on-chain.
    \item \textbf{Instant finality} -- parties can sign and exchange messages
    instantaneously without having to wait for confirmation from the blockchain.
    This is leading to a much better user experience.
    \item \textbf{Lower cost} -- digital value is exchanged with the only a few
    on-chain transactions being made for creating the channel and for closing
    the channel.
\end{itemize}

\subsubsection{Micropayments networks}

Payments channels is very promising technique for micropayments. However opening 
new channel requires on-chain transaction which is both slow and expensive and 
can't be done in setups when there are a lot of service providers. In this 
situation payment channels based solution is reasonable only when participants 
do not need to be connected to everyone else (see figure \ref{img:many-to-many}). 

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.5]{../img/many-to-many}
    \caption{Everyone makes channel with anyone else}
    \label{img:many-to-many}
\end{figure}

Many existing research on payment channels have focused on exploring the design
space of how to structure payments through intermediaries \cite{counterfactual, 
perun, lightning}. Let's suppose that Alice has a payment channel with Ingrid, and 
Ingrid has one with Bob. If Alice pays Ingrid off-chain and then Ingrid pays Bob 
the same amount, this is equivalent to Alice paying to Bob off-chain, without 
requiring a new Alice-Bob payment channel to be set up.

In situation when parties don't have channels with single intermediary, a 
micropayment channel network can be used together with a routing algorithm to 
send funds between any two parties in the network (see figure \ref{img:lightning}).

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.5]{../img/lightning-network}
    \caption{Micropayment channels network}
    \label{img:lightning}
\end{figure}

As micropayment channel network can keep most transactions off-chain, blockchain 
based currencies may scale to magnitudes larger user and transaction volumes than 
any currently exsting centralised solution. Also, micropayment channel networks 
allow for fast transactions thanks to \textit{instant finality} property of 
payment channels. Transaction is final as soon as it is signed and sent to 
another party, the blockchain latency does not matter. \\

\subsubsection{Hashed Timelocked Contracts and Virtual Channels}

There are various ways to create micropayments networks trustlessly (i.e. to 
ensure that Alice pays Ingrid if Ingrid pays Bob). The most popular is Hashed 
Timelock Contract (HTLC) based approach \cite{lightning}. In it's canonical way 
an equal amount of funds from both payment channels are locked up in a way that 
they can only be spent if a certain hash is revealed before a certain deadline 
(thus, locked “by hash” and “by time”). 

This technique can allow payments to be securely routed across multiple payment 
channels and is used in Bitcoin's Lightning Network and Ethereum's Raiden 
Network.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.5]{../img/htlc}
    \caption{HTLC based payment - Alice pays Dave}
    \label{img:htlc}
\end{figure}

In figure \ref{img:htlc} we see atomic value exchange over three micropayment 
channels (Alice to Bob, Bob to Carol, Carol to Dave). If Alice will pay to Dave
via Bob and Carol, she needs to ensure that Bob and Carol cannot run away with 
her money. To do so, Dave generates pre-image $R$, which is random number (shown 
as key on scheme), and then shared with Alice hash $H$ (shown as lock on scheme) 
of this pre-image. In step $2$ Alice generates an HTLC with Bob that says 
\textit{"I will pay you $X$ coins if you show me the pre-image $R$. If you don't 
show R during period $\Delta t$, I will take back my coins."}. In step $3$ Bob 
generates similar HTLC with Carol, but sets period of $\Delta t - 1$. In $4$ step 
Carol do same with Dave, but with even shorter period of $\Delta t - 2$. Then in 
step $5$ Dave will show $R$ to Carol, in next step Carol shows $R$ to Bob and 
finally Bob shows it to Alice. At this point payment of $X$ amount from Alice to 
Dave is finalsed.

HTLCs can be established in any chain of any length consisting of different 
payment channels. As an incentive for intermediate hops to forward transactionsa 
small fee can be charged for using the service of the channel. Fee payments are 
also justified as the balance on a channel gets shifted, which is only beneficial 
for balancing a lopsided channel. After a successful transaction with HTLCs, 
channel parties do not need to broadcast their contract and can just replace their
HTLC with a new commitment transaction without an HTLC. HTLCs can be combined with 
timelocks or revocable transactions changing the output of the HTLC accordingly.\\

In Ethereum blockchain, which supports advanced smart contracts, routing payments 
could be done in an alternative form via a technique known as \textit{Virtual 
channels}, introduced by \textit{Perun} paper \cite{perun} and simultaneously 
similar technique was proposed by \textit{Counterfactual} protocol (named as Meta 
channels), which use an intermediary that serves as a \textit{"virtual payments 
hub"}. Anyone with a payment channel connected to the hub could establish virtual
channels between each other (see figure \ref{img:hub}). Unlike routing payments 
via HTLCs, Hub does not need to be involved in every payment between Alice and 
Bob. This property reduces latency and costs, while increases privacy.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.5]{../img/hub}
    \caption{Virtual Payment Channel Hub}
    \label{img:hub}
\end{figure}

To open virtual channel, Alice and Bob essentially need to lock-up a set number
of coins from their payment channel with Hub. The amount of locked coins will 
become the value of the virtual channel between Alice and Bob. Notice, that the 
Hub remains financially neutral by simply mirroring balances.

This technique could be repplied to increase the length of the channel (see 
figure \ref{img:virtual-channels}). Because a virtual channel is an instance of 
an off-chain contract, increasing the length not require another transaction 
on-chain.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.6]{../img/virtual-channels}
    \caption{Bob becomes the Hub for channel between Alice and Carol}
    \label{img:virtual-channels}
\end{figure}

Virtual channels also represent a different business model from channel routing.
HTLCs have a \textit{“pay-per-payment”} fee model where there is need to 
incentivize each intermediary to route each payment. Virtual channels, on the 
other hand, have a \textit{“rent-a-path”} fee model. In this model, an 
intermediary acts as a virtual payment hub that has direct channels with multiple
parties. If Ingrid is the intermediary, then Alice and Bob pay Ingrid to keep 
the channel open for a certain period of time. Such a model might have better 
economics for high-volume micropayments.

While Perun and Counterfactual have introduced novel ways of routing payments 
across multiple intermediaries, HTLC-based routing is currently the primary 
implementation on blockchain mainnets, is better tested and much easier to 
implement.

\subsubsection{Known problems of micropayment networks}

Micropayment channels networks looks really promising but unfortunatelly they 
have couple of negative sides. 

Downside of using HTLC based micropayment networks is complicated routing. 
\textit{Lightning Network} is great for time to time low value payments, however 
it is much harder to use for frequent transactions into same receiver because of 
need of constantly checking if all parties in selected route are still alive and 
good to be used (e.g. all channels has enough funds to send payment forward).

Complicated routing issue could be solved by using payment hub model, when one 
of a fewnintermediaries have a lot of channels with end users. Downside of this 
solution is that this requires the Hub to lock a lot of funds in channels with 
all actors in the network. Another downside is that this solution is centralised 
and if hub's operator will be required to stop activities or will decide to 
shutdown servers by any reason, the whole network's payments activities will be 
stopped.

Another critique of payment channels network is that both parites (paying and 
receiving) have to be on-line during payment. This issue however is not valid for 
high frequency nano payments in decentralised networks, because we're sure, that
payer (service consumer) and payee (service provider) are on-line, otherwhise 
service wouldn't be provided and there would be no need for payment.

Finally, micropayment channel networks are really usefull when there are a lot
of people already using them. And when there are huge support for all popular 
programming languages and platforms. Unfortunatelly, them most popular solution
(Lightning Network) don't support tokens. On Ethereum there are a few promissing
projects (e.g. Raiden, Connext, Perun or Counterfactual), but they either are 
not widely adopted, either in early stage of development. Because they don't 
have rich tooling (e.g. protocol client implementations in popular languages 
like golang, rust or python) and are changing rapidly, they are quite 
complicated to implement and maintain. There are no clear winner at the moment
and trying to stick into one of general purpose payment network's could mean
choosing wrong direction which may mean either becoming main network developer,
either having complicated migration into another (much more popular at that 
time) solution in the future.

\subsection{Comparison and conclusion}

The key insight of \textit{Layer 2} soliutions is that not every transaction has
to be applied globally. All analysed solutions solves this problem in different 
ways and has different trade-offs. 

Many state channel developers see \textit{Layer 1} as the Security Layer and 
\textit{Layer 2} as the Scalability Layer. Furthermore, Layer 2 provides lower 
latency and cost per transaction that would otherwise not be possible beyond a 
certain level of throughput with Layer 1 solutions.

\begin{table}[H]\footnotesize
    \centering
    \caption{Comparison of researched solutions}
    {\begin{tabular}{|l|c|c|c|c|c|} \hline
       & \textbf{Channels} & \textbf{HTLC Network} & \textbf{Payment Hub} & \textbf{Plasma} & \textbf{Sidechain} \\
      \hline
      On-chain transactions & $\bullet\bullet\bullet$ & $\bullet\bullet$ & $\bullet\bullet$ & $\bullet$ & $\bullet$ \\
      Instant finality &  \checkmark &  \checkmark &  \checkmark & & \\
      Hight throughput & $\bullet\bullet$ & $\bullet\bullet\bullet$  & $\bullet\bullet\bullet$ & $\bullet$ & $\bullet$ \\
      Off-chain messaging & $\bullet$ & $\bullet\bullet\bullet$ & $\bullet\bullet$ & $\bullet$ & $\bullet$ \\
      Decentralised & \checkmark & \checkmark & $\pm$ & $?$ & $\pm$ \\
      Requires specialised wallet & $?$ & \checkmark & \checkmark & \checkmark & \checkmark \\
      Topup from exchange & $?$ & $-$ & $-$ & $-$ & \checkmark \\
      Easily embedable & \checkmark & $\pm$ & $-$ & $\pm$ & $\pm$ \\
      Overall user experience & $\bullet$ & $\bullet$ & $\bullet\bullet\bullet$ & $\bullet\bullet$ & $\bullet\bullet$ \\
      Implementation complexity & $\bullet$ & $\bullet\bullet\bullet$ & $\bullet\bullet$ & $\bullet\bullet\bullet$ & $\bullet\bullet\bullet$ \\
      Fast settlement & $?$ & $-$ & $\pm$ & \checkmark & $-$ \\
      Security & $\bullet\bullet\bullet$ & $\bullet\bullet\bullet$ & $\bullet\bullet\bullet$ & $\bullet\bullet\bullet$ & $?$ \\
      Utility token support & \checkmark & \checkmark & \checkmark & \checkmark & \checkmark \\
      \hline
    \end{tabular}}
    \label{tab:comparison}
  \end{table}

Explanation of meaning of used symbols: 
$\bullet\bullet\bullet$ -- high, 
$\bullet\bullet$ -- medium, 
$\bullet$ -- low, 
\checkmark -- yes, 
$\pm$ -- more or less, 
$?$ -- unknown, depends on implementation. \\

Explanation of compared solutions:

\begin{itemize}
    \item \textbf{Channels} -- pure payment channels bease solution (without 
    network), when each pair of consumer and provider have to open new channel.
    \item \textbf{HTLC Network} -- Micropayment channels networks which is using
    hashed timelocked contracts for payment routing, e.g. Raiden Networks.
    \item \textbf{Payment Hub} -- Virtual channels hubs based payment solution,
    such as Perun, Counterfactual or Connext.
    \item \textbf{Plasma} -- One of Plasma chain implementations (e.g. Plasma 
    MVP), dedicated to serve for payment purposes for particular distributed
    system.
    \item \textbf{Sidechain} -- Running sidechain using Substrate or Tendermint
    frameworks and connected to Polkadot or Cosmos.
\end{itemize}

In table \ref{tab:comparison} we can see comparison of properties given by 
analysed solutions. It is clear, that because of \textit{instant finality} and 
higher throughput posibilities, micropayment channels based solutions (such as
state channels, htlc networks or virtual payment hubs) fits better for high 
freakquency micropayments in decentralised platforms.

\section{Accountant pattern - lightweight payment protocol}

After analysing currently available options became obvious that at this stage
it may be better solution to introduce own, lightweight, state channels based,
easy to implement and maintain solution. 

In this section idea of \textit{"Accountant pattern"} protocol will be 
described. Essentially it is solution taking best parts of Payment promises,
uni-directional channles and paying using single intermediary taking use of 
hashed timelocked contracts for avoding need of introducing trusted custodian.

\subsection{Payments over "Accountant"}

Digital cheques or \textit{Payment promises} is elegant, efficient and easy to 
implement solution. Thanks to some modifications (comparing to initial solution,
described in 2.2 section) they have to be signed by only one party, are easy to 
verify, don't require complicated setup procedure, have practically unlimited 
amount of updates and require to store only last version of issued promise.

Main problems of using them is possibility to do double spending which pushes 
for more often on-chain settlements. To solve this problem there is suggestion 
to introduce one more party called \textit{Accountant} which should see and 
verify promises issued by consumer and be aware of actual balance of consumer's
funds (see figure \ref{img:unidirectional-payments}).

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.5]{../img/unidirectional-payments}
    \caption{Payments via Accountant}
    \label{img:unidirectional-payments}
\end{figure}

Accountant is the most complicated to implement part of this protocol. He have 
to store state of balance of each consumer and be able to accept many requests 
to validate if transaction is valid.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.5]{../img/multi-accountants}
    \caption{Multiple accountants may be used in network}
    \label{img:multi-accountants}
\end{figure}

To maintain requirement of decentralisation there may be deployed multiple 
accountants in the network (see figure \ref{img:multi-accountants}). Each 
consumer usually works with only one accountant while providers may need to be 
aware of different accountants. Accountants are chosen by consumers but because 
of cryptographic schemes described in next sections they are non-custodian and 
can't steal any funds or cooperate with consumers to cheat against providers.

\subsection{Payment Promises based uni-directional channels}

To organise secure, non-custodian and trustless work via accountant, we have to 
maintain two types of channels: paying channels (consumer $\rightarrow$ 
accountant) and receiving channels (accountant $\rightarrow$ provider). So 
accountant plays similar role as intermediary or hub described in section 3.3.3.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.4]{../img/accountant-channels}
    \caption{Two type of channels}
    \label{img:accountant-channels}
\end{figure}

Because in our case we have situation when payments are done in one direction 
(from consumer to provider) we may organise uni-directional state channels 
which are very similar to payment promises and have most of their properties. 
The only differences are that there should be done accounting and funds freezing 
for each channel separately. Also hashlock check (HTLC described in section 
3.3.4) was added to guaranty that Accountant will not keep funds to itself.

Implementation of promise settlement function can be found above and full 
state channel smart contract can be found in github repository 
\cite{smartcontracts}.

\begin{lstlisting}[language=Solidity]
    struct Party {
        address beneficiary; // funds destination
        uint256 settled;     // total amount already settled
    }

    function settlePromise(uint256 _amount, bytes32 _lock, bytes memory _signature) public {

        bytes32 _hashlock = keccak256(abi.encode(_lock));
        address _channelId = address(this);

        address _signer = keccak256(abi.encodePacked(
                _channelId, 
                _amount, 
                _hashlock
        )).recover(_signature);
        require(_signer == operator);

        // Calculate amount of tokens to be settled.
        uint256 _unpaidAmount = _amount.sub(party.settled);
        require(_unpaidAmount > 0);

        // If signer has less tokens than asked to transfer, 
        // we can transfer as much as he has already and rest 
        // tokens can be transferred via same promise but in 
        // another tx when signer will topup channel balance.
        uint _currentBalance = token.balanceOf(_channelId);
        if (_unpaidAmount > _currentBalance) {
            _unpaidAmount = _currentBalance;
        }

        // Increase already paid amount
        party.settled = party.settled.add(_unpaidAmount);

        // Send tokens
        token.transfer(party.beneficiary, _unpaidAmount);
    }
\end{lstlisting}

Because our channels are uni-directional instead of sequence number there is 
simply used total promised amount. Smart contract is calculating difference 
between amount on given promise and already settled amount.

\[ amountToTransfer = totalPromised - alreadySettled \]

This gives high level of flexibility. Promises can be settled in any order with
any gaps (e.g. only one of thousand promised can be send to settle) and amounts 
still will be calculated properly.

\subsection{Identity registry}

Another important component of protocol is \textit{registry} where all 
identities (both, consumers and providers) and accountants should be registered. 
During registration there will be also created payment channel between consumer 
and accountnat (see figure \ref{img:registration}).

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.4]{../img/registration}
    \caption{Registration of accountant and identities}
    \label{img:registration}
\end{figure}

Because there will be need to deploy channel per each registered identity there 
have to be done optimisation in terms to save of channel deployment transaction 
fee. This protocol suggests to use \textit{EIP1167} (Minimal Proxy Contract 
\cite{eip1167}) which will proxy all requests into single 
\textit{ChannelImplementation} contract while still allow to maintain separate 
state and address per each channel (see figure \ref{img:proxy}).

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.5]{../img/proxy}
    \caption{Minical proxies pointing into single implementation}
    \label{img:proxy}
\end{figure}

Consumer (paying) channels are deployed using \textit{CREATE2} opcode \cite{create2} 
which allows deterministically calculate future channel's address.

\[ keccak256(0xff + registry + identity + keccak256(byteCode))[12:]\]

This means, that users can topup their channels even before identity was 
registered and actual smart contract code was deployed there. Also because each
channel has separate address and it's topup don't require adding any aditional 
parameters (payload) to the transaction, they can be topuped using any wallet 
with token support or directly from exchange.

\subsection{Off-chain messaging and promise exchange}

Differently than in \textit{Lightning Network} or \textit{Hub} based payment 
networks, in \textit{Accountant pattern} payments are not going thgrough 
intermediary, but are "verified" by Accountant. There is used payment promise 
exchange technique (see figure \ref{img:off-chain-interactions}).

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.5]{../img/off-chain-interactions}
    \caption{HTLC based payment - Bob pays Alice}
    \label{img:off-chain-interactions}
\end{figure}

Payment is finalised in five steps. At fist Provider have to \textit{generate 
invoice} and send it to Consumer.

\[ invoice = [hashlock, agreementId, agreementAmout] \]
\[ hashlock = keccak256(R) \]
\[ R = HugeRandomNumber \]

Then Consumer issues payment promise, which allows Accountant to settle given 
amount of funds, pack it into so called \textit{Exchange message} and send back 
to Provider. 

\[ Message = keccak256(channelId, totalPromisedAmount, hashlock) \]
\[ Signature = sign(Message) \]
\[ Promise = [Message, Signature]\]
\[ ExchangeMessage = [Promise, agreementId, agreementAmout] \]

In next steps Provider is exchanging promises with Accountant so in the end 
Accountant have promise to settle funds in Consumer's channel and Provider 
have payment promise to settle same amount of funds in Accountant's channel.

\[ \Delta amount = newAgreementAmout - seenAgreementAmout \]
\[ totalPromisedAmount = previousPromisedAmount + \Delta amount \]

Provider can do same promise exchange operations with many consumers at once. 
After any number of succesfull off-chain interactions, provider at any point, 
in single transaction, can settle last payment promise with accomulated amount 
of payments done by couple of consumers (see figure \ref{img:payment}. 
Aditionally, if Provider is willing to take some risk (up to some amount) he 
can verify (exchange promises with accountant) not each payment and reduce 
amount of off-chain communication and fee paid to Accountant.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.4]{../img/payment}
    \caption{Provider settles aggregated promise}
    \label{img:payment}
\end{figure}

Accountant is also accomulating payment promises given by same Consumer to 
different Providers. When he will have payment promise with enought big value 
he can settle it on-chain (see figure \ref{img:accountant-rebalance}) and 
rebalance paying and receiving channels.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.5]{../img/accountant-rebalance}
    \caption{Accountant rebalancing is simple settlement of collected promises}
    \label{img:accountant-rebalance}
\end{figure}

\subsection{Incoming channel funds guaranties and trustless rebalance}

All analysed micropayment channel based solutions have common problem of need 
to lock funds in channels with each party. In hub based solutions this problem 
is even bigger and requires so called \textit{"rich hub"}. Thanks to possibiltiy 
to take stake and users separation to consumers and providers it is possible to 
decrease this problem.

\begin{lstlisting}[language=Vyper]
    lockedFunds: uint256 # amount of accountant funds already locked in channels
    struct Channel:
      loan: uint256      # amount lended by provider
      balance: uint256   # amount available to settle
      settled: uint256   # total amount settled by provider

    @public
    def rebalanceChannel(channelId: bytes32):
      newBalance: uint256 = channels[channelId].loan
      assert newBalance > channels[channelId].balance

      channel: Channel = channels[channelId]

      if(newBalance > channel.balance):
        lockedFunds += channel.balance - newBalance
        assert token.balanceOf(this) >= lockedFunds

      channel.balance = newBalance
\end{lstlisting}

Provider's stake can be taken and lended into Accounant and imidiatelly locked 
in his receiving payment channel. In this way, accountant will lock his own 
funds, which means that Provider can settle payment promises in value of up to 
his stake size.

Additional benefit is that Accountant can't actually withdraw and use these 
funds, so channel rebalance can be done by anyone, without accountant's 
signature.

"Always online" is big problem for payment channels. If Provider is offline or 
is under DDoS attack, he will be unable to post the finalized state (during 
dispute period) and Accountant can have possibility to take funds locked in 
channel.

Proposed method don't have such problem, because funds are double locked. 
Accountant can't leave channel with more funds than his own locked part of 
balance. So if Provider have unsettled promise for smaller amount than he 
lended to Accountant, he is safe even if he will "dissapear" for really long 
period of time. He still be able to get back all funds promised to him.

\subsection{Transaction maker}

One of most not user friendly parts of transfering ERC20 tokens is that this
operation requires to own ethers to pay for gas. Another problem in working 
with smart contracts on Ethereum is that in terms to call some function user 
have to add so called Payload (first 4 bytes of keccak of function's signature) 
which looks to him as gibberish and is not supported by many wallets and 
especially by exchanges. 

In case of topups, this problem is solved thanks to construct described in 4.3
section. Unfortunatelly for identity registration and promise settlement, user's 
application (e.g. dVPN mobile app or provider's node) would need to always have 
ethers topuped there. This is very inconvenient and may cause many problems for
both advanced users and beginners.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.45]{../img/transactor}
    \caption{Communication with blockchain via Transaction maker}
    \label{img:transactor}
\end{figure}

For identity registration and primise settlement we may take use of additional
service which we call \textit{"Transaction maker"}. The role of this service is 
to get user's requests and send transactions into blockchain (see figure 
\ref{img:transactor}).

All smart contracts created for Accounant pattern are constructed in a way, so
any their call can be made from any account simply by adding channel's operator
signature as parameter for function call. Additionaly we construct payment 
promises in a way so only one signature is needed and it is possibile to settle 
them in any order with any gaps. This means that promises can we published 
openly without any risk of attack or losing funds.

There could be deployed as many such services as needed.vEach network participant 
could decide to use own \textit{"Transaction maker"}, or even there could be 
version of accountant operator software where such service is integral part.

Sending transactions into blockchain costs so users could cover that cost, but
instead of using additional currency (ethers in case of Ethereum), they could
pay in tokens.

There is potential misbehavior of \textit{"Transaction maker"}, when he is
getting paid but didn't do his job, or misbehavior of users when they decide
not pay after transaction was sent to blockchain by \textit{"Transaction 
maker"}. To resolve this problem, functions of smart contracts usually have fee
parameter in them.

\begin{lstlisting}[language=Solidity]
    function settlePromise(uint256 _amount, bytes32 _lock, uint256 _fee, bytes memory _signature) public {

        require(_amount >= _fee);
        
        ...

        // Send tokens
        token.transfer(
            party.beneficiary, 
            _unpaidAmount.sub(_fee)
        );

        // Pay fee for transaction maker
        if (_fee > 0) {
            token.transfer(msg.sender, _fee);
        }
    }
\end{lstlisting}

In this way \textit{"Transaction maker"} will get his reward only if he actually 
will send transtation and users have no chance not to pay.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.5]{../img/transactor-payment}
    \caption{Paying via Tramsaction maker flow}
    \label{img:transactor-payment}
\end{figure}

\subsection{Properties of the protocol}

This protocol was design to be integral part of some decentralised system and 
is not aimed to work as general purpose payment network used in many 
application and daily life, when each party in the same time can receive and 
send funds. 

Main properties of protocol are:

\begin{itemize}
  \item Easy paying channel topup (even from exchange).
  \item Payments aggregation $\Longrightarrow$ minimal on-chain tx amount.
  \item Fast settlement into blockchain without need for other party to be 
  on-line and cooperate.
  \item Guaranty of incomming channel balance/collateral size.
  \item Simple off-chain communication (one roundtrip payments).
  \item Possibility to avoid accountant for at least part of transactions.
  \item Pull based interations with accountant $\Longrightarrow$ providers don't 
  have to be externally exposed or maintain live connection with accountant.
  \item Secure $\Longrightarrow$ double spend protection using non-custodian 
  accountant model.
  \item Fast channel opening $\Longrightarrow$ possibility not to wait until 
  opening tx will be mined.
  \item Instant finality of payments.
\end{itemize}

\section{Potential future work}

There are three main directions in which future development of payment solution
could evolve: 
\begin{itemize}
    \item migrate into Connext or Perun;
    \item migrate into Plasma + channels;
    \item add support of counterfactual channels for accountant pattern.
\end{itemize}

\subsection{Migration into Connext or Perun}

Two most closed and most promissing solutions to described Accontant pattern are
\textit{Perun virtual payment hubs} and \textit{Connext hub}. While Perun team 
is still working on their first version of protocol implementation, Connext team 
already working on thirs iteration of their hub solution (this time using 
Counterfactual state channels). Unfortunatelly at the moment both solutions are
not ready to use inside dVPN application written by Mysterium team. 

In Connext case, they're changing their solution a lot, so it's worth to wait 
until their implementation will stabilise. Also their client application is 
written in TypeScript which means that Mysterium would need to reimplement it 
in golang and take care of all protocol changes. Another problem is, that their
off-chain messaging is much more complicated and requires storing a quite a lot
of state by client nodes.

Perun team is creating their client node using golang, which makes it good
choice, but because protocol itself is complicated and implementation is in 
early stage, there is quite hard to say if it will work as expected and will
provide all needed features for good user experience (described in 2.3 section, 
7th requirement).

In the future, when these solutions will be more mature and if Accountat pattern
will not serve as expected, there may be made migration into one of these 
solutions.

\subsection{Plasma plus channels}

In Ethereum community there are a lot of development going aroud various Plasma 
implementations. Unfortunatelly each analysed Plasma implementation had own 
issues (either centralisation, either mass exit risk, either having support only
for non-fungible tokens). Additionaly, as was described in 3.2 section, in 
initial state running own Plasma could be expensive, and there are no popular
and decentralised Plasma implementation runned by thirs party teams.

In the future however, if there would be proposed Plasma implementation which
solves earlier mentioned problems, would have already developed tooling which
would help to run own implementaiton easily or they would appear decentralised
and popular solution implemented and runned by third party team, Mysterium team 
could easyly enough adapt their dVPN node software to use uni-directional, 
payment promise based channels on top of Plasma.

\subsection{Take use of Counterfactual state channels}

Generalized state channels described in Counterfactual \cite{counterfactual} 
white paper looks like very powerful sulution. Also we see that there is some
traction around this solution. If this trend will grow, in the future we may
take some effort to research possibility to refactor Accounant pattern proposed 
uni-directional channels and implement them in counterfactual way. Ideally there
could be possible to install them as an application on top of existing opened 
channel with counterfactual hub. This would help to have minimal changes inside 
dVPN node software but in same time be part of bigger network.

\newpage
\printbibliography[heading=bibintoc]

\end{document}
