// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.6.0 <0.7.0;

import { ECDSA } from "@openzeppelin/contracts/cryptography/ECDSA.sol";
import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol";
import { IERC20Token } from "./interfaces/IERC20Token.sol";
import { FundsRecovery } from "./FundsRecovery.sol";

interface HermesContract {
    function getOperator() external view returns (address);
}

contract ChannelImplementation is FundsRecovery {
    using ECDSA for bytes32;
    using SafeMath for uint256;

    string constant EXIT_PREFIX = "Exit request:";
    uint256 constant DELAY_BLOCKS = 18000;  // +/- 4 days

    struct ExitRequest {
        uint256 timelock;          // block number after which exit can be finalized
        address beneficiary;       // address where funds will be send after finalizing exit request
    }

    struct Hermes {
        address operator;          // signing address
        address contractAddress;   // hermes smart contract address, funds will be send there
        uint256 settled;           // total amount already settled by hermes
    }

    ExitRequest public exitRequest;
    Hermes public hermes;
    address public operator;          // channel operator = sha3(IdentityPublicKey)[:20]
    address public dex;

    event PromiseSettled(address beneficiary, uint256 amount, uint256 totalSettled);
    event ChannelInitialised(address operator, address hermes);
    event ExitRequested(uint256 timelock);
    event FinalizeExit(uint256 amount);

    /*
      ------------------------------------------- SETUP -------------------------------------------
    */

    // Fallback function - redirect ethers topup into DEX
    receive() external payable {
        (bool success, ) = address(dex).call{value: msg.value}(msg.data);
        require(success, "Tx was rejected by DEX");
    }

    // Because of proxy pattern this function is used insted of constructor.
    // Have to be called right after proxy deployment.
    function initialize(address _token, address _dex, address _identityHash, address _hermesId, uint256 _fee) public {
        require(!isInitialized(), "Is already initialized");
        require(_identityHash != address(0), "Identity can't be zero");
        require(_hermesId != address(0), "HermesID can't be zero");
        require(_token != address(0), "Token can't be deployd into zero address");

        token = IERC20Token(_token);
        dex = _dex;

        // Transfer required fee to msg.sender (most probably Registry)
        if (_fee > 0) {
            token.transfer(msg.sender, _fee);
        }

        operator = _identityHash;
        transferOwnership(operator);
        hermes = Hermes(HermesContract(_hermesId).getOperator(), _hermesId, 0);

        emit ChannelInitialised(_identityHash, _hermesId);
    }

    function isInitialized() public view returns (bool) {
        return operator != address(0);
    }

    /*
      -------------------------------------- MAIN FUNCTIONALITY -----------------------------------
    */

    // Settle promise
    // signedMessage: channelId, totalSettleAmount, fee, hashlock
    // _lock is random number generated by receiver used in HTLC
    function settlePromise(uint256 _amount, uint256 _transactorFee, bytes32 _lock, bytes memory _signature) public {
        bytes32 _hashlock = keccak256(abi.encode(_lock));
        address _channelId = address(this);
        address _signer = keccak256(abi.encodePacked(uint256(_channelId), _amount, _transactorFee, _hashlock)).recover(_signature);
        require(_signer == operator, "have to be signed by channel operator");

        // Calculate amount of tokens to be claimed.
        uint256 _unpaidAmount = _amount.sub(hermes.settled);
        require(_unpaidAmount > 0, "amount to settle should be greater that already settled");

        // If signer has less tokens than asked to transfer, we can transfer as much as he has already
        // and rest tokens can be transferred via same promise but in another tx
        // when signer will top up channel balance.
        uint256 _currentBalance = token.balanceOf(_channelId);
        if (_unpaidAmount > _currentBalance) {
            _unpaidAmount = _currentBalance;
        }

        // Increase already paid amount
        hermes.settled = hermes.settled.add(_unpaidAmount);

        // Send tokens
        token.transfer(hermes.contractAddress, _unpaidAmount.sub(_transactorFee));

        // Pay fee to transaction maker
        if (_transactorFee > 0) {
            token.transfer(msg.sender, _transactorFee);
        }

        emit PromiseSettled(hermes.contractAddress, _unpaidAmount, hermes.settled);
    }

    // Returns blocknumber until which exit request should be locked
    function getTimelock() internal view virtual returns (uint256) {
        return block.number + DELAY_BLOCKS;
    }

    // Start withdrawal of deposited but still not settled funds
    // NOTE _validUntil is needed for replay protection
    function requestExit(address _beneficiary, uint256 _validUntil, bytes memory _signature) public {
        uint256 _timelock = getTimelock();

        require(exitRequest.timelock == 0, "new exit can be requested only when old one was finalised");
        require(_validUntil > block.number, "valid until have to be greater than current block number");
        require(_timelock > _validUntil, "request have to be valid shorter than DELAY_BLOCKS");
        require(_beneficiary != address(0), "beneficiary can't be zero address");

        if (msg.sender != operator) {
            address _channelId = address(this);
            address _signer = keccak256(abi.encodePacked(EXIT_PREFIX, _channelId, _beneficiary, _validUntil)).recover(_signature);
            require(_signer == operator, "have to be signed by operator");
        }

        exitRequest = ExitRequest(_timelock, _beneficiary);

        emit ExitRequested(_timelock);
    }

    // Anyone can finalize exit request after timelock block passed
    function finalizeExit() public {
        require(exitRequest.timelock != 0 && block.number >= exitRequest.timelock, "exit have to be requested and timelock have to be in past");

        // Exit with all not settled funds
        uint256 amount = token.balanceOf(address(this));
        token.transfer(exitRequest.beneficiary, amount);

        exitRequest = ExitRequest(0, address(0));  // deleting request
        emit FinalizeExit(amount);
    }

    /*
      ------------------------------------------ HELPERS ------------------------------------------
    */

    // Setting new destination of funds recovery.
    string constant FUNDS_DESTINATION_PREFIX = "Set funds destination:";
    uint256 internal lastNonce;
    function setFundsDestinationByCheque(address payable _newDestination, uint256 _nonce, bytes memory _signature) public {
        require(_newDestination != address(0));
        require(_nonce > lastNonce, "nonce have to be bigger than last one");

        address _signer = keccak256(abi.encodePacked(FUNDS_DESTINATION_PREFIX, _newDestination, _nonce)).recover(_signature);
        require(_signer == operator, "have to be signed by proper identity");

        emit DestinationChanged(fundsDestination, _newDestination);

        fundsDestination = _newDestination;
        lastNonce = _nonce;
    }

}
